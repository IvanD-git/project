import numpy as np
import matplotlib.pyplot as plt



'''-------------------------------------------------------------'''
def mnk_straight(y_arr, x_arr=None, N=None, plot=True, k=True, b=True):
    """
        Выполняет линейную аппроксимацию данных методом наименьших квадратов (МНК).
        Аппроксимирует зависимость Y от X прямой вида: y = k*x + b.

        Parameters:
        ----------
        y_arr : array-like
        x_arr : array-like, optional
        N : int, optional
            Количество используемых точек для расчёта. По умолчанию равно длине массива y_arr.
        plot : bool, optional
        k: float, optional
        b: float, optional

         Returns
    -------
    k_approx : float
        Найденный или заданный показатель экспоненты.

    b_approx : float
        Найденный или заданный амплитудный коэффициент
    """
    if len(y_arr) == 0:
        return None

    # Если x_arr не задан, создаём его по индексам
    if x_arr is None:
        x_arr = np.arange(len(y_arr))
    else:
        x_arr = np.asarray(x_arr)

    if N is None:
        N = len(y_arr)

    x = x_arr[:N]
    y = y_arr[:N]

    math_expectX = x.sum() / N
    math_expectY = y.sum() / N

    # Вычисляем первый и второй начальные моменты
    a1 = np.dot(x, y) / N
    a2 = np.dot(x, x) / N

    # Коэффициенты линейной регрессии: y = k*x + b
    if k is True:
        k_approx = (a1 - math_expectX * math_expectY) / (a2 - math_expectX ** 2)
    else:
        k_approx = k

    if b is True:
        b_approx = math_expectY - k_approx * math_expectX
    else:
        b_approx = b


    # Аппроксимированные значения
    f_approx = k_approx * x + b_approx

    if plot:
        plt.figure(figsize=(10, 6))
        plt.scatter(x, y, s=20, c='blue', label='Исходные данные')
        plt.plot(x, f_approx, c='red', label=f'Аппроксимация: y = {k_approx:.4f}x + {b_approx:.4f}')
        plt.grid(True)
        plt.legend()
        plt.title('Линейная аппроксимация МНК')
        plt.xlabel('X')
        plt.ylabel('Y')
        plt.show()

    return k_approx, b_approx


def mnk_exponent(y_arr, x_arr=None, N=None, plot=True, k=True, a=True):
    """
    Выполняет экспоненциальную аппроксимацию данных методом наименьших квадратов (МНК).

    Аппроксимирует зависимость Y от X функцией вида: y = a * exp(k * x) с помощью линеаризации.
    Позволяет зафиксировать значение одного или обоих коэффициентов (k или a),
    чтобы они не рассчитывались заново.

    Parameters
    ----------
    y_arr : array-like, arrаy > 0
    x_arr : array-like, optional
    N : int, optional
        Количество используемых точек для расчёта. По умолчанию равно длине массива y_arr.
    plot : bool, optional
    k : bool or float, optional
    a : bool or float, optional

    Returns
    -------
    k_approx : float
        Найденный или заданный показатель экспоненты.

    a_approx : float
        Найденный или заданный амплитудный коэффициент.
    """

    if len(y_arr) == 0:
        return None

    if any(val <= 0 for val in y_arr):
        raise ValueError("Все значения в y_arr должны быть положительными для логарифмирования.")

    # Если x_arr не задан, создаём его как последовательность индексов
    if x_arr is None:
        x_arr = np.arange(len(y_arr))
    else:
        x_arr = np.asarray(x_arr)

    if N is None:
        N = len(y_arr)

    x = x_arr[:N]
    y = y_arr[:N]

    # Линеаризация: ln(y) = ln(a) + k*x
    log_y = np.log(y)

    # Обработка параметра k
    if k is True:
        math_expectX = x.sum() / N
        math_expectY = log_y.sum() / N

        a1 = np.dot(x, log_y) / N
        a2 = np.dot(x, x) / N

        k_approx = (a1 - math_expectX * math_expectY) / (a2 - math_expectX ** 2)
    elif isinstance(k, (int, float)):
        k_approx = float(k)
    else:
        raise ValueError("Параметр 'k' должен быть либо True, либо числом.")

    # Обработка параметра a
    if a is True:
        log_a_approx = math_expectY - k_approx * math_expectX
        a_approx = np.exp(log_a_approx)
    elif isinstance(a, (int, float)):
        a_approx = float(a)
    else:
        raise ValueError("Параметр 'a' должен быть либо True, либо числом.")

    # Аппроксимированные значения
    f_approx = a_approx * np.exp(k_approx * x)

    if plot:
        plt.figure(figsize=(10, 6))
        plt.scatter(x, y, s=20, c='blue', label='Исходные данные')
        plt.plot(x, f_approx, c='red', label=f'Аппроксимация: y = {a_approx:.4f}·exp({k_approx:.4f}x)')
        plt.grid(True)
        plt.legend()
        plt.title('Экспоненциальная аппроксимация методом наименьших квадратов')
        plt.xlabel('X')
        plt.ylabel('Y')
        plt.show()

    return k_approx, a_approx


import numpy as np
import matplotlib.pyplot as plt


def mnk_logarithmic(y_arr, x_arr=None, N=None, plot=True, a=True, b=True):
    """
    Выполняет аппроксимацию данных методом наименьших квадратов (МНК)
    по логарифмической функции вида: y = a + b * ln(x)

    Parameters:
    -----------
    y_arr : array-like
    x_arr : array-like, optional, >0
    N : int, optional
        Количество используемых точек. По умолчанию равно длине y_arr.
    plot : bool, optional
    a : bool or float, optional
    b : bool or float, optional

    Returns:
    --------
    a_approx : float
        Найденный или заданный коэффициент сдвига (свободный член).

    b_approx : float
        Найденный или заданный коэффициент при логарифме.

    """

    if len(y_arr) == 0:
        return None

    # Если x_arr не задан, создаём его как последовательность индексов + 1 (чтобы избежать ln(0))
    if x_arr is None:
        x_arr = np.arange(1, len(y_arr) + 1)
    else:
        x_arr = np.asarray(x_arr)
        if any(x <= 0 for x in x_arr):
            raise ValueError("Все значения x должны быть > 0 для вычисления ln(x).")

    if N is None:
        N = len(y_arr)

    x = x_arr[:N]
    y = y_arr[:N]

    # Преобразуем x -> ln(x)
    ln_x = np.log(x)

    # Обработка параметров a и b
    if b is True and a is True:
        # Оба коэффициента рассчитываются
        sum_y = y.sum()
        sum_lnx = ln_x.sum()
        sum_lnx2 = np.dot(ln_x, ln_x)
        sum_ylx = np.dot(y, ln_x)

        b_approx = (N * sum_ylx - sum_y * sum_lnx) / (N * sum_lnx2 - sum_lnx ** 2)
        a_approx = (sum_y - b_approx * sum_lnx) / N

    elif b is True and a is not True:
        # Зафиксирован a, рассчитываем b
        a_approx = float(a)
        b_approx = np.dot(y - a_approx, ln_x) / np.dot(ln_x, ln_x)

    elif a is True and b is not True:
        # Зафиксирован b, рассчитываем a
        b_approx = float(b)
        a_approx = (y - b_approx * ln_x).mean()

    elif isinstance(a, (int, float)) and isinstance(b, (int, float)):
        # Оба коэффициента зафиксированы
        a_approx = float(a)
        b_approx = float(b)

    else:
        raise ValueError("Параметры 'a' и 'b' должны быть либо True, либо числами.")

    # Аппроксимированные значения
    f_approx = a_approx + b_approx * ln_x

    if plot:
        plt.figure(figsize=(10, 6))
        plt.scatter(x, y, s=20, c='blue', label='Исходные данные')
        plt.plot(x, f_approx, c='red', label=f'Аппроксимация: y = {a_approx:.4f} + {b_approx:.4f}·ln(x)')
        plt.grid(True)
        plt.legend()
        plt.title('Логарифмическая аппроксимация МНК')
        plt.xlabel('X')
        plt.ylabel('Y')
        plt.show()

    return a_approx, b_approx


import numpy as np
import matplotlib.pyplot as plt


def approx_moving_average(y_arr, x_arr=None, window=5, plot=True):
    """
    Выполняет аппроксимацию данных методом скользящего среднего.

    Функция рассчитывает скользящее среднее для заданного массива Y
    и строит его как аппроксимирующую кривую, отражающую общий тренд данных.

    Parameters:
    -----------
    y_arr : array-like
    x_arr : array-like, optional
    window : int, optional (default=5)
        Размер окна скользящего среднего.
    plot : bool, optional (default=True)

    Returns:
    --------
    x_smooth : np.array
    y_smooth : np.array

    """

    if len(y_arr) == 0:
        raise ValueError("Входной массив 'y_arr' пуст.")

    if not isinstance(window, int) or window <= 0:
        raise ValueError("Параметр 'window' должен быть положительным целым числом.")

    if window > len(y_arr):
        raise ValueError("Размер окна не может превышать длину входного массива.")

    # Если x_arr не задан, создаём как индексы
    if x_arr is None:
        x_arr = np.arange(len(y_arr))
    else:
        x_arr = np.asarray(x_arr)

    y = np.asarray(y_arr, dtype=np.float64)

    # Расчёт скользящего среднего (режим 'valid')
    cumsum = np.cumsum(np.insert(y, 0, 0))
    y_smooth = (cumsum[window:] - cumsum[:-window]) / float(window)

    # Соответствующие значения x для точек скользящего среднего
    x_smooth = x_arr[window - 1:]

    if plot:
        plt.figure(figsize=(10, 6))
        plt.scatter(x_arr, y_arr, s=20, color='blue', label='Исходные данные')
        plt.plot(x_smooth, y_smooth, color='red', linewidth=2, label=f'Скользящее среднее (окно={window})')
        plt.grid(True)
        plt.legend()
        plt.title('Аппроксимация по скользящему среднему')
        plt.xlabel('X')
        plt.ylabel('Y')
        plt.tight_layout()
        plt.show()

    return x_smooth, y_smooth


def mnk_polynomial(y_arr, x_arr=None, N=None, degree=3, plot=True):
    """
    Выполняет полиномиальную аппроксимацию данных методом наименьших квадратов (МНК).
    Аппроксимирует зависимость Y от X полиномом n-й степени:
        y = a0 + a1*x + a2*x^2 + ... + an*x^n

    Parameters:
    -----------
    y_arr : array-like
    x_arr : array-like, optional
    N : int, optional
    degree : int, optional
    plot : bool, optional

    Returns:
    --------
    coefficients : array
        Коэффициенты полинома, начиная с a0 (свободный член) до a_degree.
    """

    if len(y_arr) == 0:
        return None

    # Если x_arr не задан, создаём как индексы
    if x_arr is None:
        x_arr = np.arange(len(y_arr))
    else:
        x_arr = np.asarray(x_arr)

    if N is None:
        N = len(y_arr)

    x = x_arr[:N]
    y = y_arr[:N]

    # Построение матрицы Vандермонда: [1, x, x^2, ..., x^degree]
    A = np.vander(x, degree + 1, increasing=True)

    # Решение системы МНК: A.T @ A @ coeffs = A.T @ y
    ATA = A.T @ A
    ATy = A.T @ y
    coefficients = np.linalg.solve(ATA, ATy)

    # Аппроксимированные значения
    f_approx = np.polyval(np.flip(coefficients), x)

    if plot:
        plt.figure(figsize=(10, 6))
        plt.scatter(x, y, s=30, c='blue', label='Исходные данные')
        plt.plot(x, f_approx, c='red', label=f'Полином {degree}-й степени')
        plt.grid(True)
        plt.legend()
        plt.title(f'Полиномиальная аппроксимация (степень {degree})')
        plt.xlabel('X')
        plt.ylabel('Y')
        plt.show()

    return coefficients

